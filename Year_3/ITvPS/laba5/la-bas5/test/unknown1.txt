Графы. Отношения
Граф можно определить как произвольную систему связей (ветвей), установленную на множестве вершин. Ветви в графе называются ребрами. Ребра могут быть однонаправленными (ориентированный граф) и двунаправленными (неориентированный граф), а также могут иметь дополнительные (например, числовые) характеристики (нагруженные ребра). Ориентация ребер и их нагрузка имеют отношение к задачам, которые решаются при помощи алгоритмов, работающих на графах (например, нагруженные ребра могут обозначать пропускную способность, расстояния и т.п.). Нас же, прежде всего, интересуют способы представления графов и общие принципы программирования для них. Конкретные алгоритмы будут приводиться здесь как иллюстрация общего подхода.
Способы представления графов
Для представления графов можно использовать различные табличные и списковые структуры. Самой простой и «близкой к математике» является матрица смежности. Это квадратная матрица, индексами в которой являются номера вершин. При наличии между вершинами с номерами i,j ребра с весом m значение элемента Aij=m, при отсутствии ребра значение элемента нулевое. В неориентированном графе матрица симметрична относительно главной диагонали, которая также является нулевой. Для приведенного на рисунке графа матрица смежности определяется в массиве таким образом:
 Для задания переменной размерности используется массив указателей на строки матрицы. Другой более компактный способ – это таблица ребер. Однако он повышает трудоемкость алгоритмов за счет перебора всей таблицы при поиске ребер для заданной вершины.
 Обеспечить прямой доступ к множеству ребер любой вершины и при этом эффективно использовать память можно на основе структур данных, использующих указатели. Это может быть, например, массив указателей на массивы или на списки описателей ребер.
Поисковые задачи на графах
С помощью графов решаются различные поисковые и оптимизационные задачи. Образная модель (см. 3.4) их решения включает в себя различные варианты «движения» по ребрам графа. Здесь можно выделить две основных идеи:
        если алгоритм решает задачу путем присоединения на каждом шаге еще одной вершины к множеству просмотренных, то он является «жадным» и имеет трудоемкость вида T=O(N2), поскольку состоит из N шагов по присоединению вершин, на каждом из которых выбирается одна из еще не просмотренных. Такие алгоритмы являются эффективными, но требуют обоснования «жадности»;
        если алгоритм рассматривает все возможные последовательности присоединения вершин, то он имеет экспоненциальную трудоемкость, поскольку содержит в своей основе полный комбинаторный перебор. Так, если вершина имеет в среднем mветвей, то она может быть оценена как T=O((m-1)N).
Полный рекурсивный обход графа. Задачи, в которых рассматриваются все возможные последовательности вершин графа (пути), могут быть реализованы с помощью рекурсивного алгоритма полного обхода графа. Инвариантом рекурсии здесь является текущая вершина и последовательность пройденных вершин (путь).  Как минимум, нужно просто отмечать пройденные вершины. Это исключает их повторное посещение и «зацикливание» рекурсии. По возвращении из рекурсивного вызова отметка снимается, что позволяет выполнять обход всех путей независимо друг от друга.
При представлении графа различными структурами данных сущность алгоритма обхода не меняется. Рекурсивная функция получает индекс текущей вершины и отмечает ее в глобальном массиве D, через который различные шаги рекурсии взаимодействуют между собой. Затем просматривается множество соседей, и для неотмеченных вершин функция вызывается рекурсивно. По окончании текущего вызова отметка текущей вершины снимается.
Такой алгоритм уже использовался нами для решения «задачи коммивояжера». Там он был дополнен необходимыми деталями: прямым накоплением пройденного пути (с передачей через формальный параметр) и сохранением последовательности пройденных вершин (городов) в глобальном массиве.
Что касается эффективных «жадных» алгоритмов, то все они имеют соответствующее «образное» представление. Оно используется не только для проектирования алгоритма, но и является частью обоснования его «жадности», т.е. однозначности выбора. В качестве примеров рассмотрим наиболее простые и образно очевидные алгоритмы.
Поиск кратчайших путей. Алгоритм Дейкстры. Алгоритм поиска кратчайших путей вычисляет минимальные расстояния вершин графа от его начальной вершины - Di. «Жадность» его состоит в том, что на каждом шаге он включает в множество вершин с вычисленными путями (в терминах алгоритма – «облако») еще одну вершину:
        первоначально в каждой вершине устанавливается «бесконечная» длина пути (больше большего) – Di=∞, начальная вершина получает нулевое расстояние D0=0, «облако» не содержит вершин;
        на каждом шаге в «облако» включается одна вершина  k с минимальным Sk, вычисленным ранее;
        после включения вершины корректируются расстояния всех ее соседей, если они находятся вне «облака», и новые вычисленные длины путей Di=Dk+Mk,i , просчитанные от включенной вершины, уменьшают ранее вычисленное значение Di.
 А теперь несколько слов к обоснованию «жадности». Алгоритм имеет ярко выраженный индуктивный характер и содержит следующий инвариант:
        «облако» состоит из подмножества вершин с минимальными расстояниями , на каждом шаге Di для вершин в «облаке» будет меньше, чем у вершин вне его;
        смежные вершины, не включенные в «облако», также содержат Di, соответствующие минимальным расстояниям при достижении их из текущего «облака»;
        инвариантное свойство «облака» сохраняется путем выбора смежной вершины вне «облака» с минимальным Di;
        инвариантное свойство смежных вершин сохраняется путем коррекции расстояний до них.
Построение минимального остового дерева. Алгоритм Прима-Ярвика. Удалив из графа некоторые ребра, можно превратить его в дерево. Если оно включает в себя все вершины исходного графа, то оно называется остовым. Кстати, в качестве его корня можно принять любую вершину, и в любом графе существует множество различных остовых деревьев. Задача состоит в построении дерева с минимальной суммой весов (значений нагруженных ребер). Идея «жадного» алгоритма состоит в присоединении на каждом шаге к минимальному дереву очередной вершины (само собой, находящейся вне дерева) с использованием ребра минимального веса. Обоснование алгоритма элементарно проводится методом математической индукции: при присоединении очередной вершины алгоритм сохраняется свойства «древовидности» (соединяя пару вершин в дереве и вне его) и «минимальности» - используя возможное ребро с минимальным весом. По аналогии с предыдущим алгоритмом множество вершин строящегося дерева называется «облаком».
Построение минимального остового дерева. Алгоритм Крускала. Другая индуктивно доказываемая идея – при объединении двух минимальных остовых поддеревьев через минимальное ребро получается минимальное остовое дерево на том же множестве вершин. Каждое поддерево называется кластером и первоначально все вершины исходного графа «сами себе поддеревья - кластеры». Затем в цикле ищется ребро с минимальным  весом, соединяющее вершины разных кластеров, после чего два кластера сливаются в один, а ребро включается в остовое дерево, связанное с этим кластером. В результате получается единственный кластер – минимальное остовое дерево.
 Между двумя крайностями – полным рекурсивным перебором последовательностей вершин и «жадным» их присоединением – находятся алгоритмы, использующие промежуточные решения. К ним относится рассмотренный в 7.5 «волновой» алгоритм построения кратчайших путей. На основе явной очереди вершин алгоритм моделирует «волну», которая распространяется из исходной вершины. Когда она достигает некоторой вершины, то для вершины устанавливается значение пройденного «волной» пути и делаются попытки скорректировать  этот же параметр у соседей. Если он корректируется в сторону уменьшения, то соседняя вершина также становится источником вторичной «волны» (т.е. помещается в очередь). Такой алгоритм не является «жадным», поскольку допускает повторную коррекцию расстояний у вершин, но он также далек от полного перебора. Оценку трудоемкости здесь проводить не будем.
 
