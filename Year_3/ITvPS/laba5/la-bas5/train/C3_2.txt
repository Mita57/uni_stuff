Стохастический (вероятностный) синтаксический анализ
В отличие от лексико-грамматического анализа текста, синтаксический анализ – развивающаяся область прикладной лингвистики. Цель синтаксического анализа - автоматическое построение функционального дерева фразы, т.е. нахождение взаимозависимостей между разноуровневыми элементами предложения. Считается, что, имея успешно построенное функциональное дерево фразы, можно выделить из предложения смысловые элементы: логический субъект, логический предикат, прямые и косвенные дополнения и различные виды обстоятельств. 
При синтаксическом анализе текста на естественном языке основной проблемой является разрешение синтаксических неоднозначностей. К этой проблеме существуют два подхода: формально-грамматический и вероятностно-статистический. Первый направлен на создание сложных систем правил, которые позволяли бы в каждом конкретном случае принимать решение в пользу той или иной синтаксической структуры; второй - на сбор статистики встречаемости различных структур в похожем контексте, на основе которой и принимается решение о выборе варианта структуры. И хотя первый подход может обеспечить более высокую точность анализатора, второй нередко оказывается практичнее. 
В современных зарубежных разработках большое внимание уделяется именно статистическим схемам анализа. Основу большинства статистических методов анализа составляют так называемые PCFG-грамматики (probabilistic context-free grammars), являющиеся, по сути, КС-грамматиками (контекстно-свободными), в которых каждое правило дополнено некоторой вероятностной оценкой. Хотя использование простой КС-грамматики не позволяет достигнуть требуемой степени точности анализа, различные схемы анализа, построенные на расширениях КС-грамматик, успешно используются в современных естественно-языковых системах.
Перечислим типы алгоритмов вывода синтаксической структуры предложения:
- Нисходящий парсер (англ. top-down parser) — продукции грамматики раскрываются, начиная со стартового символа, до получения требуемой последовательности токенов. 
LL-анализатор
- Восходящий парсер (англ. bottom-up parser) — продукции восстанавливаются из правых частей, начиная с токенов и кончая стартовым символом. 
LR-анализатор
GLR-парсер
Восстановление после ошибок. Простейший способ реагирования на некорректную входную цепочку лексем — завершить синтаксический анализ и вывести сообщение об ошибке. Однако часто оказывается полезным найти за одну попытку синтаксического анализа как можно больше ошибок. Именно так ведут себя трансляторы большинства распространённых языков программирования.
Таким образом, перед обработчиком ошибок синтаксического анализатора стоят следующие задачи:
1. он должен ясно и точно сообщать о наличии ошибок;
2. он должен обеспечивать быстрое восстановление после ошибки, чтобы продолжать поиск других ошибок;
3. он не должен существенно замедлять обработку корректной входной цепочки.
Ниже описаны наиболее известные стратегии восстановления после ошибок. Восстановление в режиме паники. При обнаружении ошибки синтаксический анализатор пропускает входные лексемы по одной, пока не будет найдена одна из специально определенного множества синхронизирующих лексем. Обычно такими лексемами являются разделители, например, ;,) или }. Набор синхронизирующих лексем должен определять разработчик анализируемого языка. При такой стратегии восстановления может оказаться, что значительное количество символов будут пропущены без проверки на наличие дополнительных ошибок. Данная стратегия восстановления наиболее проста в реализации.
Восстановление на уровне фразы. Иногда при обнаружении ошибки синтаксический анализатор может выполнить локальную коррекцию входного потока так, чтобы это позволило ему продолжать работу. Например, перед точкой с запятой, отделяющей различные операторы в языке программирования, синтаксический анализатор может закрыть все ещё не закрытые круглые скобки. Это более сложный в проектировании и реализации способ, однако в некоторых ситуациях, он может работать значительно лучше восстановления в режиме паники. Естественно, данная стратегия бессильна, если настоящая ошибка произошла до точки обнаружения ошибки синтаксическим анализатором.
Продукции ошибок. Знание наиболее распространённых ошибок позволяет расширить грамматику языка продукциями, порождающими ошибочные конструкции. При срабатывании таких продукций регистрируется ошибка, но синтаксический анализатор продолжает работать в обычном режиме.
Опишем дерево синтаксического анализа (синтаксическое дерево).
В практике синтаксического анализа используются только контексно-свободные ФГ. Кроме формальных оснований (сложность и эффективность алгоритмов работы анализаторов) этому способствуют и особенности содержательной работы с такими ФГ: система подстановок (непосредственных выводов) в такой ФГ образует древовидную структуру – дерево синтаксического анализа (ДСА) или синтаксическое дерево:
каждому правилу ФГ соответствует поддерево, в котором символ левой части образует вершину-предка, а символы правой части – вершины-потомки;
·непосредственному выводу с заменой левой части на правую соответствует процесс построения дерева «сверху-вниз» от предка к потомкам;
непосредственному выводу с заменой правой части правила на левую соответствует достраивание вершины – предка над группой вершин – потомков;
корневой вершиной ДСА является вершина с начальным нетерминалом Z.
конечными (терминальными) вершинами ДСА являются вершины, содержащие терминальные символы ФГ;
последовательность терминальных вершин, обойденная слева направо, образует предложение языка, для которого построено ДСА.
Справедливости ради следует заметить, что «ветвление» дерева происходит только в том случае, если в правой части правила имеется несколько нетерминалов. В противном случае (при наличии единственного нетерминала) получается линейная цепочка, как это имеет место в регулярных грамматиках.
Синтаксическое дерево является не просто иллюстрацией последовательности подстановок (выводов). Оно является единственным результатом синтаксического анализа. Фактически оно выявляет все структурные характеристики транслируемого текста, такие как вложенность или приоритеты отдельных синтаксических элементов. Порядок обхода синтаксического дерева (или то же самое, что порядок его построения) определяют последовательность выполнения операций в транслируемой программе, соответствующих отдельным правилам ФГ.
Использование синтаксического дерева не означает, что оно обязательно существует в распознавателе в виде структуры данных. Как раз наоборот. Большинство распознавателей в процессе работы производят последовательный выбор правил, соответствующий процедуре обхода дерева, при этом само дерево разворачивается «во времени». Здесь имеется прямая аналогия с рекурсивными функциями: дерево «экземпляров» представляет собой развернутую во времени последовательность вызовов функцией самой себя, а стек в каждый момент времени содержит локальный контекст (фреймы) текущей последовательности вызовов. Иногда, правда, синтаксическое дерево может быть построено, но уже как результат работы распознавателя.
И, наконец, из рекурсивного характера система правил и процесса их подстановки следует наличие стека в распознавателе. Но есть еще одно более жесткое утверждение: кроме стека распознаватель не нуждается более ни в какой дополнительной изменяемой памяти, кроме «зашитых» в нем управляющих таблиц, т.е. является конечным автоматом, работающим со входной строкой – анализируемым предложением языка. Естественно, что система команд такого распознавателя предполагает стандартные действия со стеком (операции push и pop), продвижение по входной строке и систему состояний-переходов, зависящих от текущих символов стека и входного предложения. Содержимое стека в различных распознавателях может быть разным, но имеющим один и тот же смысл по отношению к синтаксическому дереву: это граница его недостроенной части.
Понятно, что любая задача преобразования цепочек символов в рамках любой грамматики может быть решена путем полного перебора всех возможных вариантов подстановок, что влечет за собой экспоненциальную (показательную) трудоемкость решения задачи, не приемлемую в реальных условиях. Любой человек, использующий транслятор, в праве ожидать, что последний не слишком уменьшает скорость работы при росте объема транслируемой программы (то есть трудоемкость близка к линейной). 
Для этого прежде всего требуется отказаться от «тупого» перебора вариантов подстановки с возвратами к промежуточным цепочкам и обеспечить на каждом шаге выбор единственно правильного направления движения из нескольких возможных (так называемый жадный алгоритм). 
Теперь следует разобраться, в каких взаимоотношениях находятся формальные грамматики и синтаксический анализ. Синтаксис любого языка программирования определяется контекстно-свободной формальной грамматикой - системой терминальных и нетерминальных символов и множеством правил. Анализируемая программа представляется в такой грамматике предложением языка. Задача синтаксического анализа - определить, является ли это предложение правильным и построить для него последовательность непосредственных выводов из начального символа Z, или синтаксическое дерево.
Сам процесс построения дерева, равно и синтаксического анализа может быть как нисходящим, т.е. от вершины-предка к вершинам-потомкам с заменой левых частей правил на правые и наоборот, восходящим.
В этом же контексте объясняется понятие синтаксической ошибки. Если на каком-то этапе построения синтаксического дерева встречается недопустимая или тупиковая ситуация, то построенная последовательность терминальных символов соответствует синтаксически правильной части программы, а очередной «незакрытый» терминальный символ локализуется как синтаксическая ошибка.
И последнее. Сам процесс должен быть однозначным, т.е. каждому правильному предложению должно соответствовать единственное ДСА, а процесс его построения не должен содержать «возвратов», т.е. на каждом шаге алгоритма распознавания при наличии альтернативных вариантов должен выбираться каждый раз единственно верный.
